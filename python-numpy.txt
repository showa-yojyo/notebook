======================================================================
Python NumPy 利用ノート
======================================================================
NumPy_ は OpenGL のサンプルコードを Python_ で書くときに、
つまり PyOpenGL を利用するときに欠かすことの出来ない、
サードパーティー製ライブラリーというのが個人的な認識だ。

.. contents:: ノート目次

導入
======================================================================
* Windows 環境ではインストーラーからインストールするのが吉。
  ``numpy-x.y.z-win32-superpack-python2.6.exe`` みたいな名前のインストーラーをウェブで探すこと。

* インストールを終了したら、何はさておき ``README.txt`` と ``INSTALL.txt`` を一読すること。
  目をひくのは単体テストが実行できるということだが、
  これには別途 Nose_ というサードパーティー製のライブラリーを
  Python 環境にインストールしておく必要があるようだ。

  実際にやってみるとこのような感じになる::

    >>> import numpy
    >>> numpy.test()
    Running unit tests for numpy
    NumPy version 1.3.0
    NumPy is installed in D:\Python26\lib\site-packages\numpy
    Python version 2.6.5 (r265:79096, Mar 19 2010, 21:48:26) [MSC v.1500 32 bit (Intel)]
    nose version 0.10.4
    （略。ドットの列）
    ----------------------------------------------------------------------
    Ran 1882 tests in 63.040s
    
    OK (KNOWNFAIL=3, SKIP=1)
    <nose.result.TextTestResult run=1882 errors=0 failures=0>

基本
======================================================================
とりあえず ``from numpy import *`` だけで利用可能になる機能から習得していこう。
ファイル add_newdocs.py に docstring が大量に記述してあり、
これを何かテキストエディターで開いておくと、
バッファがそのまま簡易関数リファレンスとして使えないこともない。

array
-----
まずは ``array`` 周辺から習得する。
このデータ構造は任意次元のベクトル、行列、……を表現するためのものと思われる。

簡単な用語をメモしておく。

* array_like とは、関数呼び出し
  ``array(x)`` が妥当な ``x`` の型を指すようだ。
  そして、この関数が戻すオブジェクトもまた array_like だ。
* ``ndarray`` とは ``array`` 関数が実際に返すオブジェクトの型の一つ。
* shape とは array_like の行、列、……のサイズを表現する概念か。

array_like オブジェクトを生成する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* 基本は関数 ``array`` 呼び出しにて行うものだ。
  ``array`` は ``ndarray`` とか ``matrix`` 型のオブジェクトを返す関数だ。
  ::

    from numpy import *

    # ベクトルを生成するにはこのようにする。
    v = array([0., 0., 1.])

    # 行列はこう。
    m = array([[1., 0., 0.],
               [0., 1., 0.],
               [0., 0., 1.]])

* ``zeros_like``, ``ones_like``, ``empty_like`` をワンセットで習得すること。
  既存の array_like から同じ shape の array_like を生み出す関数だ。

* よく利用するのは ``ndarray`` だが、コンストラクターを直接利用せずに、
  関数 ``array``, ``zeros``, ``empty`` からオブジェクトを作成すること。

* ``copy`` 関数で array_like オブジェクトのコピーオブジェクトを
  同一あるいは別の array_like オブジェクトとして作成することができる。
  ::

    >>> import numpy as np
    >>> a = [1., 2., 3.]
    >>> np.copy(a)
    array([ 1.,  2.,  3.])

* 変わったところでは ``arange`` 関数で「連番」配列を生成できる。
  Python の ``range`` 関数の array_like 版といったところだ。
  ::

    >>> import numpy as np
    >>> np.arange(3.0)
    array([ 0.,  1.,  2.])

array_like の shape を変える
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* ``flatten`` メソッドで行列チックな構成を「一次元配列化」できる。
  ``reshape`` メソッドが一次元配列を多次元化するのとは対称的だ。
  こちらも引数が ``order`` を表すので、PyOpenGL の行列系関数に渡すときに調整できる。
  ::

    >>> import numpy as np
    >>> a = np.array([i for i in xrange(16)])  # TODO: arange のノートも欲しい
    >>> a.reshape((4, 4))
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])
    >>> a.flatten()
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15])
    >>> a.flatten('F')
    array([ 0,  4,  8, 12,  1,  5,  9, 13,  2,  6, 10, 14,  3,  7, 11, 15])

スカラー積、ベクトル積
~~~~~~~~~~~~~~~~~~~~~~
スカラー積、ベクトル積を求めたい場合、それぞれ関数 ``dot``, ``cross`` を利用すること。
::

  >>> import numpy as np
  >>> x = [1., 0., 0.]
  >>> y = [0., 1., 0.]
  >>> np.dot(x, y)
  0.0
  >>> np.cross(x, y)
  array([ 0.,  0.,  1.])

``dot`` については引数の shape さえ適合すれば行列の乗算もサポートする。
::

  >>> import numpy as np
  >>> x = [100., 200.]
  >>> M = np.array([[1., 2.],
  ...               [3., 4.]])
  >>> np.dot(x, M)
  array([  700.,  1000.])
  >>> np.dot(M, x)
  array([  500.,  1100.])

同次元 array_like オブジェクト同士で算術演算子が使える
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
``+``, ``-`` 等の二項演算子を同次元 array_like オブジェクト同士に作業させることができる。
各演算の定義は、成分ごとの算術演算のようだ。

array_like オブジェクトのスライシング
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
行列を表現する array_like オブジェクトから部分ベクトルを得るようなときには、
Python の ``list`` 同様、スライシングの技法を利用する。
::

  >>> import numpy as np
  >>> a = np.arange(24).reshape(3, 8)
  >>> a
  array([[ 0,  1,  2,  3,  4,  5,  6,  7],
         [ 8,  9, 10, 11, 12, 13, 14, 15],
         [16, 17, 18, 19, 20, 21, 22, 23]])
  >>> a[:,0]
  array([ 0,  8, 16])
  >>> a[0,:]
  array([0, 1, 2, 3, 4, 5, 6, 7])

ベクトルの長さ
~~~~~~~~~~~~~~
一次元の array_like をベクトルとみなすのが楽なのだが、
array_like それ自体は自身の「長さ」を計算するメソッドがない。
仕方がないので ``dot`` を利用する。

 >>> import math, numpy as np
 >>> v = array([1., 1., 1.])
 >>> math.sqrt(np.dot(v, v)) # ちなみに sqrt 関数は np にもある。
 1.7320508075688772

ベクトル正規化
~~~~~~~~~~~~~~
正規化とは長さが 1 になるようにベクトルの成分を定数倍することとする。
それには、ベクトルの長さを上述の方法で得てから、
長さが非ゼロであることを確認後、array_like オブジェクトに対して ``/=`` する。
右辺に長さを指定する。

ベクトルの一致
~~~~~~~~~~~~~~
同次元空間にある 2 ベクトル ``v1``, ``v2`` が等しいか否かのテストをする。
要するに、アプリケーション定義のトレランスを与えて、
両者の差ベクトルの長さがそれ以内に収まっているかどうかを調べる。
何を言いたいのかというと、関数 ``allclose`` を生のまま使うなということだ。

ベクトルのなす角
~~~~~~~~~~~~~~~~
これも自分でコードを書く。
2 ベクトルのスカラー積 (``dot``) とそれぞれの長さからなす角の cos が求まる。

2 ベクトルの位置関係判定
~~~~~~~~~~~~~~~~~~~~~~~~
大抵 ``dot`` と ``cross`` を組み合わせたりすれば何とかなる。

一発で identity matrix を生成する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
関数 ``eye`` を利用する。
::

  >>> import numpy as np
  >>> np.eye(4)
  array([[ 1.,  0.,  0.,  0.],
         [ 0.,  1.,  0.,  0.],
         [ 0.,  0.,  1.,  0.],
         [ 0.,  0.,  0.,  1.]])

ずばり ``identity`` という関数も存在するが、タイプし易いほうを選ぶ。

対角行列を生成する
~~~~~~~~~~~~~~~~~~
関数 ``diag`` を利用すると、手軽に対角行列を作成できる。
::

  >>> import numpy as np
  >>> A = np.diag([1.,2.,3.])
  >>> A
  array([[ 1.,  0.,  0.],
         [ 0.,  2.,  0.],
         [ 0.,  0.,  3.]])

行列から対角成分を抽出する
~~~~~~~~~~~~~~~~~~~~~~~~~~
やはり関数 ``diag`` を利用する。
引数に二次元の array_like を渡すこと。
::

  >>> # 上の続き
  >>> np.diag(A)
  array([1., 2., 3.])


統計
----
NumPy は標本を表現するデータ構造としても array_like を利用している。
平均値計算等、統計関連の機能がメソッドの形式で提供されていることがある。

総和
~~~~

最小値、最大値、平均値、中央値
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

偏差
~~~~

ヒストグラム
~~~~~~~~~~~~

応用
======================================================================
TBW

その他の話題
======================================================================
* ``add_newdocs.py`` がドキュメントのかたまりみたいになっている。一読すべし。
* ``doc/glossary.py`` が用語集を docstring の形式で記述している。
  ノートを書く前にこれを読めばよかった。

.. _Numpy: http://scipy.org/NumPy/
.. _Python: http://www.python.org/
.. _Nose: http://somethingaboutorange.com/mrl/projects/nose/
